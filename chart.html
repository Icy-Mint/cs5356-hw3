<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Annual Energy Comparison</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; /* ← CHANGED */
      margin: 2rem;
      line-height: 1.6;  /* ← ADDED */
      color: #222;       /* ← ADDED for improved text contrast */
    }
    .chart-container {
      display: flex;
      flex-wrap: wrap;
      gap: 2rem;
      margin-top: 2rem;
    }
    #annual-chart, #pie-chart {
      flex: 1 1 400px;
    }
    #line-chart {
      flex: 1 1 100%;
      margin-top: 1rem;
      min-height: 300px;
    }
    .legend rect {
      stroke: #fff;
      stroke-width: 1px;
    }
    .category-title {
      font-weight: 600;           /* ← CHANGED */
      font-size: 1.4rem;          /* ← CHANGED */
      margin-bottom: 1.5rem;      /* ← CHANGED */
      text-align: center;
    }
    .chart-title {
      font-weight: 600;           /* ← CHANGED from bold */
      font-size: 1.4rem;          /* ← CHANGED from 1.2rem */
      margin-bottom: 1.5rem;      /* ← CHANGED for better spacing */
      text-align: center;
      color: #2a2a2a;             /* ← ADDED for subtle emphasis */
    }
    .bar, .pie-slice {
      cursor: pointer;
    }
    #instructions {
      background-color: #f8f9fa;
      padding: 1rem;
      border-radius: 4px;
      margin-top: 1rem;
    }
    #annual-chart {
      flex: 1 1 600px;
      margin-bottom: 2rem;
    }
    #pie-chart {
      flex: 1 1 400px;
    }
    /* ADD THIS BELOW to prevent svg verflow*/
    svg {
      overflow: visible; /* Prevent clipping of axes and legends */
    }

    #annual-chart {
      overflow: visible; /* Prevent clipping of chart elements */
    }
    /* ----- dark‑grey axes everywhere ----- */
    .axis path,
    .axis line   { stroke: #555; }
    .axis text   { fill:   #555; }
  </style>
</head>
<body>
  <a href="import.html" style="display: inline-block; margin: 1rem 2rem; color: #333; text-decoration: none;"
     onmouseover="this.style.textDecoration='underline'"
     onmouseout="this.style.textDecoration='none'">← Back to Previous Page</a>

  <h2>Energy Visualization Dashboard</h2>
  <!--  Tooltip container for hover display -->
  <div id="tooltip" style="position: absolute; opacity: 0; background: #fff; padding: 6px 10px; border: 1px solid #ccc; border-radius: 4px; pointer-events: none; font-size: 12px;"></div> 
  <div class="chart-container">
    <div id="annual-chart">
      <div class="chart-title">Annual Energy Comparison</div>
    </div>
    <div id="pie-chart">
      <div class="chart-title">Energy Use by Category (<span id="pie-data-type">Current</span>)</div>
    </div>
    <div id="line-chart">
      <div class="chart-title">Monthly Trend: <span id="selected-category">Select a category</span></div>
    </div>
  </div>

  <script>
    // Load data from local storage
    const rawCsvCurrent = localStorage.getItem("iesveCsvData");
    const rawCsvFuture = localStorage.getItem("iesveFutureCsvData");
    const tooltip = d3.select("#tooltip"); // This line initializes the tooltip reference

    if (!rawCsvCurrent) {
      document.body.innerHTML = "<p>No current energy CSV found. Please upload it first.</p>";
      throw new Error("No current CSV");
    }

    const keys = [
      "Interior Lighting (MBtu)",
      "Receptacle Equipment (MBtu)",
      "Space Heating (MBtu)",
      "Service Water Heating (MBtu)",
      "Space Cooling (MBtu)",
      "Heat Rejection (MBtu)",
      "Interior Central Fans (MBtu)",
      "Interior Local Fans (MBtu)",
      "Exhaust Fans (MBtu)",
      "Pumps (MBtu)"
    ];

    // Color scheme for consistency across charts
    const colorScale = d3.scaleOrdinal()
      .domain([
        "Interior Lighting (MBtu)",
        "Receptacle Equipment (MBtu)",
        "Space Heating (MBtu)",
        "Service Water Heating (MBtu)",
        "Space Cooling (MBtu)",
        "Heat Rejection (MBtu)",
        "Interior Central Fans (MBtu)",
        "Interior Local Fans (MBtu)",
        "Exhaust Fans (MBtu)",
        "Pumps (MBtu)"
      ])
      .range([
        "#fbb4ae", "#ccebc5", "#fb8072", "#ffffb3", "#80b1d3",
        "#b3cde3", "#bebada", "#fdb462", "#fccde5", "#d9d9d9"
      ]);
    // ADDED: Utility to get consistent color for category
    const categoryColor = category => colorScale(category) || "#888";
    // Parse CSV to get annual totals
    function parseCsvTotals(csvText) {
      const lines = csvText.split("\n").map(l => l.split(","));
      const headers = lines[4].map(h => h.trim());
      const totalRow = lines[19];
      const totals = {};
      headers.forEach((h, i) => {
        if (keys.includes(h)) {
          totals[h] = parseFloat(totalRow[i]) || 0;
        }
      });
      return totals;
    }

    // Parse CSV to get monthly data
    function parseCsvMonthly(csvText) {
      const lines = csvText.split("\n").map(l => l.split(","));
      const headers = lines[4].map(h => h.trim());
      const monthlyData = [];
      
      // Extract month rows (lines 7-18)
      for (let i = 7; i <= 18; i++) {
        const row = lines[i];
        const monthData = { month: row[0].substring(0, 3) }; // Get month abbreviation
        
        headers.forEach((h, j) => {
          if (keys.includes(h)) {
            monthData[h] = parseFloat(row[j]) || 0;
          }
        });
        
        monthlyData.push(monthData);
      }
      
      return monthlyData;
    }

    const currentTotals = parseCsvTotals(rawCsvCurrent);
    const currentMonthly = parseCsvMonthly(rawCsvCurrent);
    
    const annualChartData = [{ label: "Current", ...currentTotals }];
    let futureTotals, futureMonthly;

    // If future data exists in localStorage, use it
    if (rawCsvFuture) {
      futureTotals = parseCsvTotals(rawCsvFuture);
      futureMonthly = parseCsvMonthly(rawCsvFuture);
    } 
    // Otherwise, create example future data (70% of current as sample efficiency improvement)
    else {
      futureTotals = {};
      keys.forEach(key => {
        futureTotals[key] = currentTotals[key] * 0.7; // 30% reduction as example
      });
      
      futureMonthly = [];
      currentMonthly.forEach(monthData => {
        const futureMonth = { month: monthData.month };
        keys.forEach(key => {
          futureMonth[key] = monthData[key] * 0.7; // 30% reduction as example
        });
        futureMonthly.push(futureMonth);
      });
      
      console.log("No future data found. Using sample data (70% of current values).");
    }
    
    // Always add future data to chart
    annualChartData.push({ label: "Future", ...futureTotals });

    // Create the vertical stacked bar chart
    drawAnnualChart(annualChartData, keys);
    
    // Create initial pie chart with Current data
    drawPieChart("Current", currentTotals);
    
    // Set up placeholder for line chart
    setupLineChart();

    // Draw Annual Bar Chart
    function drawAnnualChart(data, keys) {
      const margin = { top: 40, right: 200, bottom: 60, left: 60 }, // ← Increased right margin for legend
            width = 800 - margin.left - margin.right,
            height = 450 - margin.top - margin.bottom;

      const svg = d3.select("#annual-chart")
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);

      const stack = d3.stack().keys(keys);
      const stackedData = stack(data);

      const maxTotal = d3.max(data, d => keys.reduce((sum, k) => sum + d[k], 0));

      const x = d3.scaleBand()
        .domain(data.map(d => d.label))
        .range([0, width])
        .padding(0.4);

      const y = d3.scaleLinear()
        .domain([0, maxTotal])
        .range([height, 0]);

      // Add bars with interaction
      svg.selectAll("g.layer")
        .data(stackedData)
        .join("g")
          .attr("class", d => `layer category-${d.key.replace(/\s+\([^)]+\)/g, '').replace(/\s+/g, '-').toLowerCase()}`)
          .attr("fill", d => colorScale(d.key))
        .selectAll("rect")
          .data(d => d.length ? d : [d])
          .join("rect")
            .attr("class", "bar")
      // begin of the fade in animation 
            .attr("x",      d => x(d.data.label))
            .attr("y",      y(0))                               /* start at baseline for the animation  */
            .attr("width",  x.bandwidth())
            .attr("height", 0)
            .attr("stroke", "white")
            .attr("stroke-width", 0.5)
            /* store the category so click‑handler is trivial             */
            .attr("data-category", (d,i,nodes) =>
              d3.select(nodes[i].parentNode).datum().key)       /* ← CHANGED   */

            /* ─── interaction handlers BEFORE the transition ─────────── */
            .on("mouseover", (event, d) => {
              const category = d3.select(event.currentTarget.parentNode).datum().key;
              const val      = (d[1] - d[0]).toFixed(2);
              tooltip.style("opacity", 1)
                    .html(`<strong>${category}</strong><br>${d.data.label}: ${val}&nbsp;MBtu`);
            })
            .on("mousemove",  event =>
              tooltip.style("left", (event.pageX + 10) + "px")
                    .style("top",  (event.pageY - 28) + "px"))
            .on("mouseout",   () => tooltip.style("opacity", 0))
            .on("click",      event =>
              showMonthlyTrend(event.currentTarget.dataset.category))

            /* ─── grow‑in animation ───────────────────────────────────── */
            .transition()
            .duration(800)
            .delay((d,i) => i * 100)
            .attr("y",      d => y(d[1]))
            .attr("height", d => y(d[0]) - y(d[1]))

        /* ─── optional native <title> tooltip AFTER the transition ───── */
        .selection()                                            /* ← CHANGED   jump back to the rect selection              */
        .append("title")
          .text(function(d){
              const category = d3.select(this.parentNode).datum().key;
              return `${d.data.label} – ${category}: ${(d[1]-d[0]).toFixed(2)} MBtu`;
          });
        
      // Add axes
      /* ── X‑axis ────────────────────────────────────────────────── */
      svg.append("g")
      svg.append("g")
        .attr("class", "axis")
        .attr("transform", `translate(0,${height})`)
        .call( d3.axisBottom(x)
                .tickSize(6)        // inner ticks = 6 px
                .tickSizeOuter(0) ) // no outer ticks
        .selectAll("text")
          .style("cursor", "pointer")
          .style("font-size", "13px")
          .style("font-weight", "500")
          .style("fill", "#555")     // dark‑grey
          .on("click", function (event, d) {
            d3.select(this)
              .style("fill", "red")
              .transition().duration(500)
              .style("fill", "#555");
            togglePieChart(d);
          });

      /* ── Y‑axis ─────────────────────────────────────────── */
      svg.append("g")
        .attr("class", "axis")
        .call( d3.axisLeft(y)
                .ticks(6)
                .tickSize(6)
                .tickSizeOuter(0) )
        .selectAll("text")
          .style("font-size", "13px")
          .style("font-weight", "500")
          .style("fill", "#555");
      // Add axis labels
      svg.append("text")
        .attr("x", width / 2)
        .attr("y", height + 40)
        .attr("text-anchor", "middle")
        .style("font-size", "14px")
        .style("fill", "#555")
        .text("Energy Scenario");

      svg.append("text")
        .attr("transform", "rotate(-90)")
        .attr("x", -height / 2)
        .attr("y", -60)
        .attr("text-anchor", "middle")
        .style("font-size", "14px")
        .style("fill", "#555")
        .text("Annual Energy Consumption (Million BTU)");

      // Add legend
      const legend = svg.append("g")
        .attr("transform", `translate(${width + 10}, 0)`);

      keys.forEach((key, i) => {
        const legendItem = legend.append("g")
          .attr("transform", `translate(0, ${i * 24})`)
          .style("cursor", "pointer")
          .on("click", () => showMonthlyTrend(key));
          
        legendItem.append("rect")
          .attr("width", 14)
          .attr("height", 14)
          .attr("rx", 3)  // Rounded corners
          .attr("fill", colorScale(key))
          .attr("stroke", "#555")
          .attr("stroke-width", 0.5);

        legendItem.append("text")
          .attr("x", 20)
          .attr("y", 11)
          .attr("font-size", "13px")     // ← Slightly increased
          .attr("fill", "#555")          // ← Changed from default black
          .style("font-family", "sans-serif") // ← Ensure clean sans serif
          .style("font-weight", "500")   // ← New: medium weight for clarity
          .text(key);
      });

      // Add comparison label
      svg.append("text")
        .attr("x", width / 2)
        .attr("y", -10)
        .attr("text-anchor", "middle")
        .style("font-size", "14px")
        .style("font-weight", "bold")
        .text("Current vs Future Energy Consumption");
    }

    // Draw Pie Chart
    function drawPieChart(dataType, totals) {
      d3.select("#pie-chart svg").remove();
      document.getElementById("pie-data-type").textContent = dataType;

      const margin = { top: 20, right: 20, bottom: 20, left: 20 },
            width = 400 - margin.left - margin.right,
            height = 400 - margin.top - margin.bottom,
            radius = Math.min(width, height) / 2;

      const svg = d3.select("#pie-chart")
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", `translate(${width / 2 + margin.left}, ${height / 2 + margin.top})`);

      // Convert and sort data
      let pieDataRaw = keys.map(key => ({
        category: key,
        value: totals[key] || 0
      }));

      const total = d3.sum(pieDataRaw, d => d.value);
      const threshold = 0.03; // 3%

      // Simplify: combine small values into "Other"
      const pieData = [];
      let otherTotal = 0;

      pieDataRaw.forEach(d => {
        const share = d.value / total;
        if (share < threshold) {
          otherTotal += d.value;
        } else {
          pieData.push(d);
        }
      });

      if (otherTotal > 0) {
        pieData.push({ category: "Other", value: otherTotal });
      }

      const pie = d3.pie()
        .value(d => d.value)
        .sort(null);

      const arc = d3.arc()
        .innerRadius(radius * 0.4)  // donut style
        .outerRadius(radius);

      const arcData = pie(pieData);

      // Draw slices
      svg.selectAll(".slice")
        .data(arcData)
        .join("path")
        .attr("class", "slice")
        // add animated version
        .attr("fill", d => colorScale(d.data.category) || "#ccc")
        .attr("stroke", "#fff")
        .attr("stroke-width", 1.5)
        .each(function(d) { d.endAngle = d.startAngle; }) // start with 0 arc
        .transition()
        .duration(1000)
        .attrTween("d", function(d) {
          const i = d3.interpolate(d.startAngle, d.endAngle + 0.001); // ensure small gap
          return function(t) {
            d.endAngle = i(t);
            return arc(d);
          };
        });

      // Add % labels only if > 5%
      svg.selectAll(".label")
        .style("font-size", "11px")    // ← Set uniform readable size
        .style("fill", "#333")         // ← Changed for contrast
        .style("font-weight", "500")  // ← Added for better legibility
        .data(arcData)
        .join("text")
        .attr("transform", d => `translate(${arc.centroid(d)})`)
        .attr("dy", ".35em")
        .attr("text-anchor", "middle")
        .style("font-size", "11px")
        .style("fill", "#333")
        .text(d => {
          const percent = (d.data.value / total) * 100;
          return percent >= 5 ? `${percent.toFixed(1)}%` : "";
        });

      // Add total in center
      svg.append("text")
        .attr("text-anchor", "middle")
        .attr("dy", "0.35em")
        .style("font-size", "14px")
        .style("font-weight", "bold")
        .style("fill", "#444")
        .text(`${dataType}`);

      svg.append("text")
        .attr("text-anchor", "middle")
        .attr("dy", "0.35em")
        .style("font-size", "14px")           // ← Larger and stronger
        .style("font-weight", "bold")
        .style("fill", "#444");              // ← Dark gray instead of black

    }


    // Setup Line Chart
    function setupLineChart() {
      const margin = { top: 20, right: 60, bottom: 60, left: 60 },
            width = 800 - margin.left - margin.right,
            height = 300 - margin.top - margin.bottom;

      const svg = d3.select("#line-chart")
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);
        
      // Add placeholder text
      svg.append("text")
        .attr("x", width / 2)
        .attr("y", height / 2)
        .attr("text-anchor", "middle")
        .text("Click a category in the bar or pie chart to see monthly trends");
    }

    // Show Monthly Trend for Selected Category
    function showMonthlyTrend(category) {
      // Update selected category display
      document.getElementById("selected-category").textContent = category;
      
      // Clear previous chart
      d3.select("#line-chart svg").remove();
      
      const margin = { top: 20, right: 60, bottom: 60, left: 60 },
            width = 800 - margin.left - margin.right,
            height = 300 - margin.top - margin.bottom;

      const svg = d3.select("#line-chart")
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);

      // Prepare data for both current and future if available
      const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

      const currentData = currentMonthly.map(d => ({
        month: d.month,
        value: d[category] || 0,
        type: 'Current'
      }));

      let combinedData = [...currentData];
      let futureData = null; // Initialize futureData

      if (futureMonthly) {
        futureData = futureMonthly.map(d => ({ // Assign to futureData
          month: d.month,
          value: d[category] || 0,
          type: 'Future'
        }));
        combinedData = [...currentData, ...futureData];
      }

      // Create scales
      const x = d3.scaleBand()
        .domain(monthNames)
        .range([0, width])
        .padding(0.1);

      const y = d3.scaleLinear()
        .domain([0, d3.max(combinedData, d => d.value) * 1.1])
        .range([height, 0]);

      // Add seasonal annotations (Now drawn BEFORE axes/lines/points)
      const heatingStartMonth = "Oct";
      const heatingEndMonth = "Apr";
      const coolingStartMonth = "May";
      const coolingEndMonth = "Sep";

      // Calculate correct start/end positions based on band boundaries
      const heatingStartX_Oct = x(heatingStartMonth);
      const heatingEndX_Apr = x(heatingEndMonth) + x.bandwidth();
      const coolingStartX_May = x(coolingStartMonth);
      const coolingEndX_Sep = x(coolingEndMonth) + x.bandwidth();

      // --- Heating Season ---
      // Background Shading (Part 1: Oct-Dec)
      svg.append("rect")
        .attr("x", heatingStartX_Oct)
        .attr("y", 0)
        .attr("width", width - heatingStartX_Oct)
        .attr("height", height)
        .attr("fill", "blue")
        .attr("opacity", 0.03) // Increased opacity
        .attr("stroke", "blue")
        .attr("stroke-opacity", 0.08) // Increased opacity
        .attr("stroke-width", 1);

      // Background Shading (Part 2: Jan-Apr)
      svg.append("rect")
        .attr("x", 0)
        .attr("y", 0)
        .attr("width", heatingEndX_Apr)
        .attr("height", height)
        .attr("fill", "blue")
        .attr("opacity", 0.03) // Increased opacity
        .attr("stroke", "blue")
        .attr("stroke-opacity", 0.08) // Increased opacity
        .attr("stroke-width", 1);

      // Heating Label
      const heatingLabel = svg.append("g");
      heatingLabel.append("rect") // Background rect first
        .attr("x", 5)
        .attr("y", 5)
        .attr("width", 110)
        .attr("height", 22)
        .attr("fill", "white")
        .attr("stroke", "blue")
        .attr("stroke-width", 1)
        .attr("rx", 4);
      heatingLabel.append("text") // Text on top
        .attr("x", 10)
        .attr("y", 20)
        .attr("fill", "blue")
        .style("font-size", "12px")
        .style("font-weight", "bold")
        .text("Heating Season");


      // --- Cooling Season ---
      // Background Shading (May-Sep)
      svg.append("rect")
        .attr("x", coolingStartX_May)
        .attr("y", 0)
        .attr("width", coolingEndX_Sep - coolingStartX_May)
        .attr("height", height)
        .attr("fill", "red")
        .attr("opacity", 0.08) // Increased opacity
        .attr("stroke", "red")
        .attr("stroke-opacity", 0.15) // Increased opacity
        .attr("stroke-width", 1);

      // Cooling Label
      const coolingLabel = svg.append("g");
      const coolingLabelX = coolingStartX_May + 5;
      coolingLabel.append("rect") // Background rect first
        .attr("x", coolingLabelX)
        .attr("y", 5)
        .attr("width", 110)
        .attr("height", 22)
        .attr("fill", "white")
        .attr("stroke", "red")
        .attr("stroke-width", 1)
        .attr("rx", 4);
      coolingLabel.append("text") // Text on top
        .attr("x", coolingLabelX + 5)
        .attr("y", 20)
        .attr("fill", "red")
        .style("font-size", "12px")
        .style("font-weight", "bold")
        .text("Cooling Season");


      // --- Vertical Transition Lines ---
      const seasonTransitions = ["May", "Oct"];
      seasonTransitions.forEach(month => {
        const monthX = x(month);
        svg.append("line")
          .attr("x1", monthX)
          .attr("y1", 0)
          .attr("x2", monthX)
          .attr("y2", height)
          .attr("stroke", month === "May" ? "red" : "blue")
          .attr("stroke-width", 1.5)
          .attr("stroke-dasharray", "4,4");
      });
      // --- END OF MOVED SEASONAL ANNOTATIONS ---


      // Create line generators (can stay here)
      const line = d3.line()
        .x(d => x(d.month) + x.bandwidth() / 2)
        .y(d => y(d.value))
        .curve(d3.curveBasis); // Apply curveBasis for smooth lines

      // Add axes (Now drawn AFTER seasonal annotations)
      /* ── X‑axis ─────────────────────────────────────────── */
      svg.append("g")
        .attr("class", "axis")
        .attr("transform", `translate(0,${height})`)
        .call( d3.axisBottom(x)
                .tickSize(6)
                .tickSizeOuter(0) )
        .selectAll("text")
          .style("font-size", "13px")
          .style("font-weight", "500")
          .style("fill", "#555");

      /* ── Y‑axis ─────────────────────────────────────────── */
      svg.append("g")
        .attr("class", "axis")
        .call( d3.axisLeft(y)
                .ticks(6)            // adjust if you prefer more/less ticks
                .tickSize(6)
                .tickSizeOuter(0) )
        .selectAll("text")
          .style("font-size", "13px")
          .style("font-weight", "500")
          .style("fill", "#555");

      // Add lines (Now drawn AFTER seasonal annotations)
      // Add animation for line chart 
      // ------------------------------------------------------------------
      // 1. pick colours once
      // ------------------------------------------------------------------
      const baseColor    = categoryColor(category);            // palette colour
      const currentColor = d3.color(baseColor).darker(1.3);    // darker for Current
      const futureColor  = baseColor;                          // exact match for Future

      // ------------------------------------------------------------------
      // 2. lines
      // ------------------------------------------------------------------
      const currentPath = svg.append("path")
        .datum(currentData)
        .attr("fill", "none")
        .attr("stroke", currentColor)          // ← use darker tone
        .attr("stroke-width", 2)
        .attr("d", line);

      …
      if (futureData) {
        svg.append("path")
          .datum(futureData)
          .attr("fill", "none")
          .attr("stroke", futureColor)         // ← palette colour
          .attr("stroke-width", 2)
          .attr("d", line);
      }

      // ------------------------------------------------------------------
      // 3. points
      // ------------------------------------------------------------------
      svg.selectAll(".current-point")
        .data(currentData)
        .join("circle")
        .attr("class", "current-point")
        .attr("cx", d => x(d.month) + x.bandwidth() / 2)
        .attr("cy", d => y(d.value))
        .attr("r", 4)
        .attr("fill", currentColor)            // ← match current line
        .attr("stroke", "#555")
        .attr("stroke-width", 0.5);

      if (futureData) {
        svg.selectAll(".future-point")
          .data(futureData)
          .join("circle")
          .attr("class", "future-point")
          .attr("cx", d => x(d.month) + x.bandwidth() / 2)
          .attr("cy", d => y(d.value))
          .attr("r", 4)
          .attr("fill", futureColor);          // ← match future line
      }

      // ------------------------------------------------------------------
      // 4. legend
      // ------------------------------------------------------------------
      const legend = svg.append("g")
        .attr("transform", `translate(${width - 100}, 0)`);

      legend.append("rect")                    // Current swatch
        .attr("width", 15)
        .attr("height", 15)
        .attr("fill", currentColor);

      legend.append("text")
        .attr("x", 20)
        .attr("y", 12)
        .style("fill", "#555")
        .text("Current");

      if (futureData) {
        legend.append("rect")                  // Future swatch
          .attr("x", 0)
          .attr("y", 20)
          .attr("width", 15)
          .attr("height", 15)
          .attr("fill", futureColor);

        legend.append("text")
          .attr("x", 20)
          .attr("y", 32)
          .style("fill", "#555")
          .text("Future");
      }
      // Add axis labels (can stay here)
      svg.append("text")
        .attr("x", width / 2)
        .attr("y", height + 40)
        .attr("text-anchor", "middle")
        .style("font-size", "14px")
        .text("Month");

      svg.append("text")
        .attr("transform", "rotate(-90)")
        .attr("x", -height / 2)
        .attr("y", -60)
        .attr("text-anchor", "middle")
        .style("font-size", "14px")
        .text("Energy Consumption (MBtu)");

      // Add legend (can stay here)
      const legend = svg.append("g")
        .attr("transform", `translate(${width - 100}, 0)`);

      legend.append("rect")
        .attr("x", 0)
        .attr("y", 0)
        .attr("width", 15)
        .attr("height", 15)
        .attr("fill", "#4285F4");

      legend.append("text")
        .attr("x", 20)
        .attr("y", 12)
        .text("Current");

      if (futureData) { // Check the assigned futureData variable
        legend.append("rect")
          .attr("x", 0)
          .attr("y", 20)
          .attr("width", 15)
          .attr("height", 15)
          .attr("fill", d3.color(categoryColor(category)).darker(0.8))
          .attr("stroke", "#333")
          .attr("stroke-width", 0.5);

        legend.append("text")
          .attr("x", 20)
          .attr("y", 32)
          .text("Future");
      }
    }

    // Toggle Pie Chart between Current and Future
    function togglePieChart(dataType) {
      console.log("Toggle requested for:", dataType);
      
      // Add currentDataType tracking
      if (!window.currentDataType) {
        window.currentDataType = "Current";
      }
      
      // Only toggle if different from current
      if (dataType !== window.currentDataType) {
        if (dataType === "Current") {
          drawPieChart("Current", currentTotals);
          window.currentDataType = "Current";
        } else if (dataType === "Future") {
          drawPieChart("Future", futureTotals);
          window.currentDataType = "Future";
        }
      }
      
      // Add direct toggle buttons for easier switching
      /*if (!window.toggleButtonsAdded) {
        const container = document.getElementById("pie-chart");
        const buttonDiv = document.createElement("div");
        buttonDiv.style.textAlign = "center";
        buttonDiv.style.marginTop = "10px";
        
      
        
        buttonDiv.appendChild(currentBtn);
        buttonDiv.appendChild(futureBtn);
        container.appendChild(buttonDiv);
        
        window.toggleButtonsAdded = true;
      }*/
    }
  </script>
</body>
</html>
